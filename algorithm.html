<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Voronoi Diagram Example</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="locations.js"></script>
</head>
<body>
<script type="module">
    import * as THREE from './js/three.module.min.js';
    import { SVGLoader } from './js/SVGLoader.js';
    import  { OrbitControls }  from './js/OrbitControls.js';
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    const controls = new OrbitControls( camera, renderer.domElement );
    document.body.appendChild( renderer.domElement );


    var points_pre = []
    var markers = [];
    var svgData

    get_points()



    function get_points(){
        for (var i = db.features.length - 1; i >= 0; i--) {
            markers.push(
                {    
                    position: [db.features[i].properties.lat, db.features[i].properties.lon],
                    title: '',
                    description: ''
                }
            )
          points_pre.push([db.features[i].properties.lat, db.features[i].properties.lon])
          if(i == 0){ get_svg() }
        }
    }


    function get_svg(){
        var can_w = 1000
        var can_h = 500
        // set up the SVG element
        var svg = d3.select("body")
          .append("svg")
          .attr("width", can_w)
          .attr("height", can_h);

        var min_0 = 1000
        var max_0 = 0
        var min_1 = 1000
        var max_1 = 0

        for (var i = 0; i < points_pre.length; i++) {
            if (points_pre[i][1] < min_0) {
                min_0 = points_pre[i][1];
            }
            if (points_pre[i][1] > max_0) {
                max_0 = points_pre[i][1];
            }
            if (points_pre[i][0] < min_1) {
                min_1 = points_pre[i][0];
            }
            if (points_pre[i][0] > max_1) {
                max_1 = points_pre[i][0];
            }
            if(i == points_pre.length-1){
                    console.log(min_0)
                    console.log(max_0)
                var points = Array(points_pre.length)
                var voronoi = d3.voronoi().extent([[0, 0], [can_w, can_w*(max_1-min_1)/(max_0-min_0)]]);
                for (var k = points_pre.length - 1; k >= 0; k--) {
                    points[k]=Array(2)
                    points[k][0] = map(points_pre[k][1], min_0, max_0, 0, can_w)
                    points[k][1] = map(points_pre[k][0], min_1, max_1, can_w*(max_1-min_1)/(max_0-min_0), 0)
                    console.log(can_w*(max_1-min_1)/(max_0-min_0))
                    if(k == 0){
                    var diagram = voronoi(points);
                    polygons = diagram.polygons()
                    polygons = polygons.filter(function(polygon) {
                  return polygon && polygon.length > 0 && polygon[0];
                });
                    // // draw the Voronoi diagram
                    svg.selectAll("path")
                      .data(polygons)
                      .enter().append("path")
                        .attr("d", function(d) { return "M" + d.join("L") + "Z"; })
                        .style("fill", "none")
                        .style("stroke", "black");

                        // export the SVG as a string and log it to the console
                        var serializer = new XMLSerializer();
                            svgData = serializer.serializeToString(svg.node());
                        console.log(svgString);

                    }
                }
            }
        }
    }


function make_3d(){
    const loader = new SVGLoader();
    const material = new THREE.MeshNormalMaterial();

    // Loop through all of the parsed paths
    svgData.paths.forEach((path, i) => {
    const shapes = path.toShapes(true);

        // Each path has array of shapes
        shapes.forEach((shape, j) => {
        // Finally we can take each shape and extrude it
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: 20,
                bevelEnabled: false
            });

            // Create a mesh and add it to the group
            const mesh = new THREE.Mesh(geometry, material);

            svgGroup.add(mesh);
            if(i < 0){mesh.visible = false}
        });
    });

}


    function animate() {
        requestAnimationFrame( animate );
        renderer.render( scene, camera );
    }

    animate();




function map(value, start1, stop1, start2, stop2) {
    var range1 = (value - start1) / (stop1 - start1);
    var range2 = range1 * (stop2 - start2) + start2;
    return range2;
}
    // compute the Voronoi diagram

  </script>
</body>
</html>
