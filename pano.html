<!DOCTYPE html>
<html>
<head>
	<title>NewlyFormedCity</title>
	<meta charset="utf-8">
<script src="locations.js"></script>
<script src="names.js"></script>
<script src="https://code.jquery.com/jquery-3.7.0.js" integrity="sha256-JlqSTELeR4TLqP0OG9dxM7yDPqX1ox/HfgiSLBj8+kM=" crossorigin="anonymous"></script>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="style.css">
  <link rel="icon" type="image/x-icon" href="fav.png">
</head>
<body class="pano">
		<div id="container"></div>
<script type="module">
var isMobile = false;
// device detection
if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
    isMobile = true;
    $('body').addClass('mobile')
}
    import * as THREE from './js/three.module.min.js';

			let camera, scene, renderer;

			let isUserInteracting = false,
				onPointerDownMouseX = 0, onPointerDownMouseY = 0,
				lon = 0, onPointerDownLon = 0,
				lat = 9, onPointerDownLat = 0,
				phi = 0.5, theta = 0;
var mouse = new THREE.Vector2();

var raycaster = new THREE.Raycaster();
var circle_array = []
var hash
var positions = []
var closepoints = []
				var circle_amount = 5
var hashlon
var hashlat
var wholeglobe
var prevhash =[]
var stopped =false
var resize_canvas

        var min_0 = 24.85
        var max_0 = 25.12
        var min_1 = 60.13
        var max_1 = 60.26
if(window.location.hash) {
}else{
	window.location.hash = '707_24%9520948_60%1689814_1976-6-2'
}
if(isMobile){
	console.log('111')
// document.addEventListener('contextmenu', function(event) {
//   event.preventDefault();
// });
}
function hashchange(){
		var title = window.location.hash.split('#')[(window.location.hash).split('#').length-1].split('_')[3]
		var value = find_index(title)
		$('.info').empty()
		$('.info').append('<img src="images/up.png" class="info_btn btn"><div class="upper"></div>')
		if(isMobile){
			$('.info').addClass('closed')
			$('.info_btn').click(function(){
				if($('.info').hasClass('closed')){
								$('.info').removeClass('closed')
							}else{
								$('.info').addClass('closed')
							}
			})
		}
		$('.info .upper').append('<div class="title"></div>')
		$('.info .upper').append('<div class="artist"></div>')
		$('.info .upper').append('<div class="date"></div>')
		$('.info').append('<div class="img"></div>')
		$('.info').append('<div class="des"></div>')
		$('.info .upper .title').append(names[value].title.split("'")[names[value].title.split("'").length-2])
		$('.info .upper .artist').append(names[value].artist)
		$('.info .upper .date').append(names[value].date)
		$('.info .des').append(names[value].prompt+'<br><br>')
		$('.info .img').css({'background-image':'url('+names[value].img_URL+')'})
	  	hash = 			(window.location.hash).split('#')[1].split('_')[3]
	  	console.log(hash)
	  	hashlon = parseFloat((window.location.hash).split('#')[1].split('_')[1].replace(/%/g, '.'))
	  	hashlat = parseFloat((window.location.hash).split('#')[1].split('_')[2].replace(/%/g, '.'))
                    $('.dot').css({'left':map(hashlon, min_0, max_0, 0, 1)*100+'%'})
                    $('.dot').css({'top':map(hashlat, min_1, max_1, 0, 1)*100+'%'})

	  	console.log((window.location.hash).split('#')[1].split('_'))
	  	positions = []
		for (var i = 0; i < db.features.length; i++) {
			positions.push({x : db.features[i].properties.lon, y : db.features[i].properties.lat})
		}
		closepoints = findClosestPositions(hashlon, hashlat, positions)

				for (var i = circle_amount-1; i >= 0; i--) {
					var value = closepoints[i]
					const texture00 = new THREE.TextureLoader().load( 'img/img_'+db.features[value].properties.img+'.jpg' );
					console.log(db.features[value].properties.img)
					const material00 = new THREE.MeshBasicMaterial( { map: texture00 } );
					circle_array[i].children[0].material = material00 

				    var name = ''

				    for (var k = names.length - 1; k >= 0; k--) {
				        if(names[k].object_ID == db.features[value].properties.img){
				            name = names[k].title.split("'")[names[k].title.split("'").length-2];
				        }
				    }
					circle_array[i].name = value +'_'+db.features[value].properties.lon.toString().replace(/\./g, '%')+'_'+db.features[value].properties.lat.toString().replace(/\./g, '%')+'_'+db.features[value].properties.img
					circle_array[i].children[0].name = value +'_'+db.features[value].properties.lon.toString().replace(/\./g, '%')+'_'+db.features[value].properties.lat.toString().replace(/\./g, '%')+'_'+db.features[value].properties.img
					circle_array[i].children[1].name = value +'_'+db.features[value].properties.lon.toString().replace(/\./g, '%')+'_'+db.features[value].properties.lat.toString().replace(/\./g, '%')+'_'+db.features[value].properties.img
				}
				const texture = new THREE.TextureLoader().load( 'img/img_'+hash+'.jpg' );
				console.log('img/img_'+hash+'.jpg')
				texture.colorSpace = THREE.SRGBColorSpace;
				const material = new THREE.MeshBasicMaterial( { map: texture } );
				wholeglobe.material = material
	if(!isMobile){get_info_height()}
}
function find_index(searchTitle){
	searchTitle = searchTitle
var matchingIndex = -1;

for (var i = 0; i < names.length; i++) {
  if (names[i].object_ID.toString() === searchTitle) {
    matchingIndex = i;
    console.log(i)
    break; // Exit the loop after finding the first match
  }
}

return matchingIndex;
}function findClosestPositions(x1, y1, positions) {
  function calculateDistance(x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Create an array of indices
  const indices = positions.map((_, index) => index);

  // Sort indices based on distance from [x1, y1]
  const sortedIndices = indices.sort((a, b) => {
    const distanceA = calculateDistance(positions[a].x, positions[a].y);
    const distanceB = calculateDistance(positions[b].x, positions[b].y);
    return distanceA - distanceB;
  });

  // Get the closest indices, excluding the ones with distance 0
  const closestIndices = sortedIndices.filter(index => {
    const distance = calculateDistance(positions[index].x, positions[index].y);
    return distance > 0;
  });
 closestIndices = shuffleArray(closestIndices) 
  // Return the closest indices
  return closestIndices;
}
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

$(document).ready(function(){

	if(!isMobile){get_info_height()}
			init();
			animate();

$('.back_btn').click(function(){
	if(prevhash.length >0){
		window.location.hash = prevhash[prevhash.length-1]
		prevhash.pop();
		hashchange()
	}
})

    $('.stop_btn').click(function(){
            stopped = true
            $('body').addClass('stopped')
    })
    $('.play_btn').click(function(){
            stopped = false
            $('.stopped').removeClass('stopped')
    })
    $('.des_btn').click(function(){
            $('body').addClass('desview')
    })
    $('.close_btn').click(function(){
            $('body').removeClass('desview')
    })

})

function init() {
	const container = document.getElementById( 'container' );
	if(!isMobile){camera = new THREE.PerspectiveCamera( 105, window.innerWidth / (window.innerHeight-$('.info').outerHeight()), 1, 1100 );}
	else{camera = new THREE.PerspectiveCamera( 105, window.innerWidth / (window.innerHeight), 1, 1100 );}
	scene = new THREE.Scene();
	const geometry = new THREE.SphereGeometry( 500, 60, 40 );
	// invert the geometry on the x-axis so that all of the faces point inward
	geometry.scale( - 1, 1, 1 );
	const material1 = new THREE.MeshBasicMaterial( { color:'0x000000' } );
	const mesh = new THREE.Mesh( geometry, material1 );
	wholeglobe = mesh
	scene.add( mesh );

	for (var i = circle_amount-1; i >= 0; i--) {
		var circleGroup = new THREE.Group()
		var circleGroup_inner = new THREE.Group()
		if(isMobile){
			var circleRadius = 60;
		}else{
			var circleRadius = 40;
		}
		var circleSegments = 32;
		var circleGeometry = new THREE.CircleGeometry(circleRadius, circleSegments);

		var circleMesh = new THREE.Mesh(circleGeometry, material1);
		const texture2 = new THREE.TextureLoader().load( 'img/circle-01.png' );
		const material2 = new THREE.MeshBasicMaterial( { map: texture2 , transparent: true } );
		var circleMesh_shadow = new THREE.Mesh(circleGeometry, material2);
		circleMesh_shadow.position.z = 1
		circleGroup_inner.position.z = -450

		circle_array.push(circleGroup_inner)
		circleGroup.add(circleGroup_inner)
		circleGroup_inner.add(circleMesh);
		circleGroup_inner.add(circleMesh_shadow);
		circleGroup.rotation.y = degToRad((360/circle_amount)*i)
		scene.add(circleGroup)
		if(i==0){
			hashchange()

		}
	}
      
	$('.zoomout').css({'width':(0.95924)*$('.zoomout').outerHeight()+'px'})
	if((0.95924)*$('.zoomout').outerHeight()>window.innerWidth/2){

		$('.zoomout').css({'width':window.innerWidth/2+'px'})
		$('.zoomout').css({'height':window.innerWidth/2/(0.95924)+'px'})
	}
                    $('.dot').css({'left':map(hashlon, min_0, max_0, 0, 1)*100+'%'})
                    $('.dot').css({'top':map(hashlat, min_1, max_1, 0, 1)*100+'%'})
                    if(isMobile){
window.addEventListener('touchstart', onTouchStart, false);

                    }else{
window.addEventListener('click', onMouseClick, false);

                    }


				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				if(!isMobile){renderer.setSize( window.innerWidth, (window.innerHeight-$('.info').outerHeight()) );}
				else{renderer.setSize( window.innerWidth, (window.innerHeight) );}
				container.appendChild( renderer.domElement );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointerdown', onPointerDown );

				document.addEventListener( 'wheel', onDocumentMouseWheel );

				//

				document.addEventListener( 'dragover', function ( event ) {

					event.preventDefault();
					event.dataTransfer.dropEffect = 'copy';

				} );

				document.addEventListener( 'dragenter', function () {

					document.body.style.opacity = 0.5;

				} );

				document.addEventListener( 'dragleave', function () {

					document.body.style.opacity = 1;

				} );

				document.addEventListener( 'drop', function ( event ) {

					event.preventDefault();

					const reader = new FileReader();
					reader.addEventListener( 'load', function ( event ) {

						material.map.image.src = event.target.result;
						material.map.needsUpdate = true;

					} );
					reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

					document.body.style.opacity = 1;

				} );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

function get_info_height(){
	var value
	if($('.upper').outerHeight()>$('.des').outerHeight()){
		value = $('.upper').outerHeight()
	}else{
		value = $('.des').outerHeight()
	}
	$('.info').css({'height':value+'px'})
	$('.img').css({'width':($('.info').outerWidth()/2 - $('.upper').outerWidth())+'px'})

}


function onTouchStart(event) {
  // Calculate touch position normalized device coordinates
  var touch = event.touches[0];
  mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
  if(!isMobile){mouse.y = -(touch.clientY / (window.innerHeight-$('.info').outerHeight())) * 2 + 1;
}else{mouse.y = -(touch.clientY / (window.innerHeight)) * 2 + 1}

  raycaster.setFromCamera(mouse, camera);

  var intersects = raycaster.intersectObjects(circle_array);

  // Check if any objects are intersected
  if (intersects.length > 0) {
    prevhash.push(window.location.hash);
    window.location.hash = intersects[0].object.name;
    hashchange();
    // Perform desired actions when the circle is touched
  }
}

// Handle mouse click
function onMouseClick(event) {
  // Calculate mouse position normalized device coordinates

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  if(!isMobile){mouse.y = -(event.clientY / (window.innerHeight-$('.info').outerHeight())) * 2 + 1;
}else{mouse.y = -(event.clientY / (window.innerHeight)) * 2 + 1}

  raycaster.setFromCamera(mouse, camera);

  var intersects = raycaster.intersectObjects(circle_array);

  // Check if any objects are intersected
  if (intersects.length > 0) {
  	prevhash.push(window.location.hash)
                window.location.hash = intersects[0].object.name;

                hashchange()
    // Perform desired actions when the circle is clicked
  }
}
function degToRad(degrees) {
  return degrees * (Math.PI / 180);
}
			function onWindowResize() {
				if(!isMobile){
								camera.aspect = window.innerWidth / (window.innerHeight-$('.info').outerHeight());
								renderer.setSize( window.innerWidth, (window.innerHeight-$('.info').outerHeight()) );
							}else{
								camera.aspect = window.innerWidth / (window.innerHeight);
								renderer.setSize( window.innerWidth, (window.innerHeight) );
							}

				camera.updateProjectionMatrix();
			}

			function onPointerDown( event ) {

				if ( event.isPrimary === false ) return;

				isUserInteracting = true;

				onPointerDownMouseX = event.clientX;
				onPointerDownMouseY = event.clientY;

				onPointerDownLon = lon;
				onPointerDownLat = lat;

				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerup', onPointerUp );

			}

			function onMouseMove( event ) {
				  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				  if(!isMobile){
				  				  mouse.y = -(event.clientY / (window.innerHeight-$('.info').outerHeight())) * 2 + 1;
				  				}else{
				  				  mouse.y = -(event.clientY / (window.innerHeight)) * 2 + 1;
				  				}
				  
				  raycaster.setFromCamera(mouse, camera);

				  var intersects = raycaster.intersectObjects(circle_array);
				for (var i = circle_array.length - 1; i >= 0; i--) {
					// circle_array[i].scale.set(2.5,2.5,2.5)
					 // circle_array[i].scale.y = lerp (circle_array[i].scale.y, 2.5, 0.1);
					 circle_array[i].scale.x = lerp (circle_array[i].scale.x, 1, 0.1);
					 circle_array[i].scale.y = lerp (circle_array[i].scale.y, 1, 0.1);
					 circle_array[i].scale.z = lerp (circle_array[i].scale.z, 1, 0.1);
				}
				  // Check if any objects are intersected
				  if (intersects.length > 0) {
				    console.log("Circle clicked!");
				    // intersects[0].object.scale.set(15,15,15)
					 intersects[0].object.parent.scale.x = lerp (intersects[0].object.parent.scale.x, 7.5, 0.1);
					 intersects[0].object.parent.scale.y = lerp (intersects[0].object.parent.scale.y, 7.5, 0.1);
					 intersects[0].object.parent.scale.z = lerp (intersects[0].object.parent.scale.z, 7.5, 0.1);
				    // Perform desired actions when the circle is clicked
				  }
			}
			function onPointerMove( event ) {


				if ( event.isPrimary === false ) return;

				lon = ( onPointerDownMouseX - event.clientX ) * 0.1 + onPointerDownLon;
				lat = ( event.clientY - onPointerDownMouseY ) * 0.1 + onPointerDownLat;

			}

			function onPointerUp() {

				if ( event.isPrimary === false ) return;

				isUserInteracting = false;

				document.removeEventListener( 'pointermove', onPointerMove );
				document.removeEventListener( 'pointerup', onPointerUp );

			}

			function onDocumentMouseWheel( event ) {

				const fov = camera.fov + event.deltaY * 0.05;

				camera.fov = THREE.MathUtils.clamp( fov, 10, 75 );

				camera.updateProjectionMatrix();

			}

			function animate() {

				requestAnimationFrame( animate );
				update();

			}

			function update() {

				if ( isUserInteracting === false && !stopped ) {

					lon += 0.025;

				}
				lat = Math.max( - 85, Math.min( 85, lat ) );
				phi = THREE.MathUtils.degToRad( 90 - lat );
				theta = THREE.MathUtils.degToRad( lon );

				const x = 500 * Math.sin( phi ) * Math.cos( theta );
				const y = 500 * Math.cos( phi );
				const z = 500 * Math.sin( phi ) * Math.sin( theta );

				camera.lookAt( x, y, z );

				renderer.render( scene, camera );

			}


    function map(value, start1, stop1, start2, stop2) {
        var range1 = (value - start1) / (stop1 - start1);
        var range2 = range1 * (stop2 - start2) + start2;
        return range2;
    } 
function lerp (start, end, amt){
  return (1-amt)*start+amt*end
}
		</script>
<div class="zoomout">
	<div class="dot selected_dot"></div>
</div>
<a href="http://newlyformedcity.net/#nointro">
	<img src="images/x-01.png" class="home_btn">
</a>
<div class="instruction">
    <span class="onlypano">Drag the page to explore</span>

</div>
<div class="description">
    
Team: Iacopo Neri, Yehwan Song, Ludovica Schaerf, Pepe Ballesteros, Valentine Bernasconi, Darío Negueruela del Castillo<br>
Newly formed re-imagines the city of Helsinki through the collections of the Helsinki Art museum. It is a collaborative research-driven inquiry into how an Artificial Intelligence Entity could co-curate the collections of the Helsinki Art Museum HAM.<br>
Start: You are flying over Helsinki, a series of spheres appear, containing panoramic images of locations in the city that have been re-imagined by the AI based on the artworks of the Helsinki Art Museum. Use the arrows on the screen or on the keyboard to navigate.<br>
You can click in each sphere to travel inside and be immersed in the panorama. The geometry of the spaces in the original locations are maintained, but the content of the images is an artistic vision generated by the AI Entity.<br>
Once inside the panorama, you will see some smaller spheres located in certain places of the panorama. These are the nearest locations, to which you can navigate by clicking on them. 
<br>
—----<br>
<br>
COLOPHON<br>
For more information on the methodology and the models adopted, go to LINK <br>
<img src="images/about.png">

</div>
<img src="images/stop.png" class="stop_btn">
<img src="images/play.png" class="play_btn">
<img src="images/q-01.png" class="des_btn">
<img src="images/x-01.png" class="close_btn">
	<img src="images/back.png" class="back_btn">
		<div class="info"></div>
</body>
</html>